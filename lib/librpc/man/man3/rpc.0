


RPC(3N)                        1988                       RPC(3N)


NNAAMMEE
       rpc - library routines for remote procedure calls

SSYYNNOOPPSSIISS AANNDD DDEESSCCRRIIPPTTIIOONN
       These routines allow C programs to make procedure calls on
       other machines across  the  network.   First,  the  client
       calls  a  procedure  to  send a data packet to the server.
       Upon receipt of the packet, the server  calls  a  dispatch
       routine  to  perform the requested service, and then sends
       back a reply.  Finally, the procedure call returns to  the
       client.

       Routines that are used for Secure RPC (DES authentication)
       are described in rrppcc__sseeccuurree(3N).  Secure RPC can  be  used
       only if DES encryption is available.

       ##iinncclluuddee <<rrppcc//rrppcc..hh>>

       vvooiidd
       aauutthh__ddeessttrrooyy((aauutthh))
       AAUUTTHH **aauutthh;;

              A  macro  that destroys the authentication informa-
              tion associated  with  _a_u_t_h.   Destruction  usually
              involves  deallocation  of private data structures.
              The  use  of  _a_u_t_h  is  undefined   after   calling
              aauutthh__ddeessttrrooyy(()).

       AAUUTTHH **
       aauutthhnnoonnee__ccrreeaattee(())

              Create  and  returns  an  RPC authentication handle
              that passes  nonusable  authentication  information
              with  each  remote  procedure  call.  This  is  the
              default authentication used by RPC.

       AAUUTTHH **
       aauutthhuunniixx__ccrreeaattee((hhoosstt,, uuiidd,, ggiidd,, lleenn,, aauupp__ggiiddss))
       cchhaarr **hhoosstt;;
       iinntt uuiidd,, ggiidd,, lleenn,, **aauupp..ggiiddss;;

              Create and return an RPC authentication handle that
              contains authentication information.  The parameter
              _h_o_s_t is the name of the machine on which the infor-
              mation was created; _u_i_d is the user's user ID ; _g_i_d
              is the user's current group ID ; _l_e_n  and  _a_u_p__g_i_d_s
              refer  to  a  counted  array of groups to which the
              user belongs.  It is easy to impersonate a user.

       AAUUTTHH **
       aauutthhuunniixx__ccrreeaattee__ddeeffaauulltt(())

              Calls aauutthhuunniixx__ccrreeaattee(()) with the appropriate param-
              eters.



February                        16                              1





RPC(3N)                        1988                       RPC(3N)


       ccaallllrrppcc((hhoosstt,, pprrooggnnuumm,, vveerrssnnuumm,, pprrooccnnuumm,, iinnpprroocc,, iinn,, oouuttpprroocc,, oouutt))
       cchhaarr **hhoosstt;;
       uu__lloonngg pprrooggnnuumm,, vveerrssnnuumm,, pprrooccnnuumm;;
       cchhaarr **iinn,, **oouutt;;
       xxddrrpprroocc__tt iinnpprroocc,, oouuttpprroocc;;

              Call  the remote procedure associated with _p_r_o_g_n_u_m,
              _v_e_r_s_n_u_m, and _p_r_o_c_n_u_m on  the  machine,  _h_o_s_t.   The
              parameter  _i_n  is  the  address  of the procedure's
              argument(s), and _o_u_t is the  address  of  where  to
              place  the  result(s); _i_n_p_r_o_c is used to encode the
              procedure's parameters,  and  _o_u_t_p_r_o_c  is  used  to
              decode   the  procedure's  results.   This  routine
              returns zero if it succeeds, or the value  of  eennuumm
              ccllnntt__ssttaatt cast to an integer if it fails.  The rou-
              tine ccllnntt__ppeerrrrnnoo(()) is handy for translating failure
              statuses into messages.

              Warning:  calling  remote procedures with this rou-
              tine   uses   UDP/IP   as    a    transport;    see
              ccllnnttuuddpp__ccrreeaattee(()) for restrictions.  You do not have
              control of timeouts or  authentication  using  this
              routine.

       eennuumm ccllnntt__ssttaatt
       ccllnntt__bbrrooaaddccaasstt((pprrooggnnuumm,, vveerrssnnuumm,, pprrooccnnuumm,, iinnpprroocc,, iinn,, oouuttpprroocc,, oouutt,, eeaacchhrreessuulltt))
       uu__lloonngg pprrooggnnuumm,, vveerrssnnuumm,, pprrooccnnuumm;;
       cchhaarr **iinn,, **oouutt;;
       xxddrrpprroocc__tt iinnpprroocc,, oouuttpprroocc;;
       rreessuullttpprroocc__tt eeaacchhrreessuulltt;;

              Like  ccaallllrrppcc(()),  except the call message is broad-
              cast to all locally connected broadcast nets.  Each
              time  it  receives  a  response, this routine calls
              eeaacchhrreessuulltt(()), whose form is:

                 eeaacchhrreessuulltt((oouutt,, aaddddrr))
                 cchhaarr **oouutt;;
                 ssttrruucctt ssoocckkaaddddrr__iinn **aaddddrr;;

              where  _o_u_t  is  the   same   as   _o_u_t   passed   to
              ccllnntt__bbrrooaaddccaasstt(()),  except  that  the  remote proce-
              dure's output is decoded there; _a_d_d_r points to  the
              address  of  the machine that sent the results.  If
              eeaacchhrreessuulltt(()) returns zero,  ccllnntt__bbrrooaaddccaasstt(())  waits
              for  more replies; otherwise it returns with appro-
              priate status.

              Warning: broadcast sockets are limited in  size  to
              the  maximum  transfer  unit  of the data link. For
              ethernet, this value is 1500 bytes.

       eennuumm ccllnntt__ssttaatt
       ccllnntt__ccaallll((ccllnntt,, pprrooccnnuumm,, iinnpprroocc,, iinn,, oouuttpprroocc,, oouutt,, ttoouutt))



February                        16                              2





RPC(3N)                        1988                       RPC(3N)


       CCLLIIEENNTT **ccllnntt;;
       uu__lloonngg
       pprrooccnnuumm;;
       xxddrrpprroocc__tt iinnpprroocc,, oouuttpprroocc;;
       cchhaarr **iinn,, **oouutt;;
       ssttrruucctt ttiimmeevvaall ttoouutt;;

              A macro that calls  the  remote  procedure  _p_r_o_c_n_u_m
              associated  with  the client handle, _c_l_n_t, which is
              obtained with an RPC client creation  routine  such
              as  ccllnntt__ccrreeaattee(()).  The parameter _i_n is the address
              of the procedure's  argument(s),  and  _o_u_t  is  the
              address  of where to place the result(s); _i_n_p_r_o_c is
              used to encode the procedure's parameters, and _o_u_t-
              _p_r_o_c  is  used  to  decode the procedure's results;
              _t_o_u_t is the time allowed for results to come  back.

       ccllnntt__ddeessttrrooyy((ccllnntt))
       CCLLIIEENNTT **ccllnntt;;

              A  macro  that  destroys  the  client's RPC handle.
              Destruction usually involves deallocation  of  pri-
              vate  data  structures, including _c_l_n_t itself.  Use
              of _c_l_n_t is undefined after calling  ccllnntt__ddeessttrrooyy(()).
              If the RPC library opened the associated socket, it
              will close it also.  Otherwise, the socket  remains
              open.

       CCLLIIEENNTT **
       ccllnntt__ccrreeaattee((hhoosstt,, pprroogg,, vveerrss,, pprroottoo))
       cchhaarr **hhoosstt;;
       uu__lloonngg pprroogg,, vveerrss;;
       cchhaarr **pprroottoo;;

              Generic  client  creation routine.  _h_o_s_t identifies
              the name of the remote host  where  the  server  is
              located.   _p_r_o_t_o  indicates which kind of transport
              protocol to use. The currently supported values for
              this  field  are udp and tcp.  Default timeouts are
              set, but can be modified using ccllnntt__ccoonnttrrooll(()).

              Warning: Using UDP  has  its  shortcomings.   Since
              UDP-based RPC messages can only hold up to 8 Kbytes
              of encoded data, this transport cannot be used  for
              procedures that take large arguments or return huge
              results.

       bbooooll__tt
       ccllnntt__ccoonnttrrooll((ccll,, rreeqq,, iinnffoo))
       CCLLIIEENNTT **ccll;;
       cchhaarr **iinnffoo;;

              A macro used to change or retrieve various informa-
              tion about a client object.  _r_e_q indicates the type



February                        16                              3





RPC(3N)                        1988                       RPC(3N)


              of operation, and _i_n_f_o is a pointer to the informa-
              tion. For both UDP and TCP, the supported values of
              _r_e_q and their argument types and what they do are:

              CLSET_TIMEOUT       struct timeval      set total timeout
              CLGET_TIMEOUT       struct timeval      get total timeout

              Note: if you set the timeout using  ccllnntt__ccoonnttrrooll(()),
              the timeout parameter passed to ccllnntt__ccaallll(()) will be
              ignored in all future calls.

              CLGET_SERVER_ADDR   struct sockaddr_in  get server's address

              The following operations are valid for UDP only:

              CLSET_RETRY_TIMEOUT struct timevalset the retry timeout
              CLGET_RETRY_TIMEOUT struct timevalget the retry timeout

              The retry timeout is the time that  UDP  RPC  waits
              for  the  server to reply before retransmitting the
              request.

       ccllnntt__ffrreeeerreess((ccllnntt,, oouuttpprroocc,, oouutt))
       CCLLIIEENNTT **ccllnntt;;
       xxddrrpprroocc__tt oouuttpprroocc;;
       cchhaarr **oouutt;;

              A macro  that  frees  any  data  allocated  by  the
              RPC/XDR  system  when  it decoded the results of an
              RPC call.  The parameter _o_u_t is the address of  the
              results,  and _o_u_t_p_r_o_c is the XDR routine describing
              the results.   This  routine  returns  one  if  the
              results  were  successfully  freed, and zero other-
              wise.

       vvooiidd
       ccllnntt__ggeetteerrrr((ccllnntt,, eerrrrpp))
       CCLLIIEENNTT **ccllnntt;;
       ssttrruucctt rrppcc__eerrrr **eerrrrpp;;

              A macro that copies the error structure out of  the
              client handle to the structure at address _e_r_r_p.

       vvooiidd
       ccllnntt__ppccrreeaatteeeerrrroorr((ss))
       cchhaarr **ss;;

              Print  a message to standard error indicating why a
              client RPC handle could not be created.   The  mes-
              sage  is prepended with string _s and a colon.  Used
              when     a     ccllnntt__ccrreeaattee(()),     ccllnnttrraaww__ccrreeaattee(()),
              ccllnnttttccpp__ccrreeaattee(()), or ccllnnttuuddpp__ccrreeaattee(()) call fails.

       vvooiidd



February                        16                              4





RPC(3N)                        1988                       RPC(3N)


       ccllnntt__ppeerrrrnnoo((ssttaatt))
       eennuumm ccllnntt__ssttaatt ssttaatt;;

              Print  a message to standard error corresponding to
              the  condition  indicated  by  _s_t_a_t.   Used   after
              ccaallllrrppcc(()).

       ccllnntt__ppeerrrroorr((ccllnntt,, ss))
       CCLLIIEENNTT **ccllnntt;;
       cchhaarr **ss;;

              Print a message to standard error indicating why an
              RPC call failed; _c_l_n_t is the handle used to do  the
              call.  The message is prepended with string _s and a
              colon.  Used after ccllnntt__ccaallll(()).

       cchhaarr **
       ccllnntt__ssppccrreeaatteeeerrrroorr
       cchhaarr **ss;;

              Like ccllnntt__ppccrreeaatteeeerrrroorr(()), except that it returns  a
              string instead of printing to the standard error.

              Bugs:  returns pointer to static data that is over-
              written on each call.

       cchhaarr **
       ccllnntt__ssppeerrrrnnoo((ssttaatt))
       eennuumm ccllnntt__ssttaatt ssttaatt;;

              Take  the  same  arguments  as  ccllnntt__ppeerrrrnnoo(()),  but
              instead  of sending a message to the standard error
              indicating why an RPC call failed, return a pointer
              to a string which contains the message.  The string
              ends with a NEWLINE.

              ccllnntt__ssppeerrrrnnoo(()) is used instead of ccllnntt__ppeerrrrnnoo(())  if
              the  program  does  not have a standard error (as a
              program running as a server quite likely does not),
              or  if  the programmer does not want the message to
              be output with pprriinnttff, or if a message format  dif-
              ferent  than  that supported by ccllnntt__ppeerrrrnnoo(()) is to
              be   used.    Note:   unlike   ccllnntt__ssppeerrrroorr(())   and
              ccllnntt__ssppccrreeaatteerrrroorr(()), ccllnntt__ssppeerrrrnnoo(()) returns pointer
              to static data, but the result will not  get  over-
              written on each call.

       cchhaarr **
       ccllnntt__ssppeerrrroorr((rrppcchh,, ss))
       CCLLIIEENNTT **rrppcchh;;
       cchhaarr **ss;;

              Like     ccllnntt__ppeerrrroorr(()),     except    that    (like
              ccllnntt__ssppeerrrrnnoo(())) it  returns  a  string  instead  of



February                        16                              5





RPC(3N)                        1988                       RPC(3N)


              printing to standard error.

              Bugs:  returns pointer to static data that is over-
              written on each call.

       CCLLIIEENNTT **
       ccllnnttrraaww__ccrreeaattee((pprrooggnnuumm,, vveerrssnnuumm))
       uu__lloonngg pprrooggnnuumm,, vveerrssnnuumm;;

              This routine creates  a  toy  RPC  client  for  the
              remote   program  _p_r_o_g_n_u_m,  version  _v_e_r_s_n_u_m.   The
              transport used to pass messages to the  service  is
              actually  a  buffer  within  the  process's address
              space, so the corresponding RPC server should  live
              in  the  same  address  space; see ssvvccrraaww__ccrreeaattee(()).
              This allows simulation of RPC  and  acquisition  of
              RPC  overheads,  such  as round trip times, without
              any kernel interference. This routine returns  NULL
              if it fails.

       CCLLIIEENNTT **
       ccllnnttttccpp__ccrreeaattee((aaddddrr,, pprrooggnnuumm,, vveerrssnnuumm,, ssoocckkpp,, sseennddsszz,, rreeccvvsszz))
       ssttrruucctt ssoocckkaaddddrr__iinn **aaddddrr;;
       uu__lloonngg pprrooggnnuumm,, vveerrssnnuumm;;
       iinntt **ssoocckkpp;;
       uu__iinntt sseennddsszz,, rreeccvvsszz;;

              This  routine  creates an RPC client for the remote
              program _p_r_o_g_n_u_m, version _v_e_r_s_n_u_m; the  client  uses
              TCP/IP  as  a  transport.  The  remote  program  is
              located   at   Internet    address    *_a_d_d_r.     If
              aaddddrr-->>ssiinn__ppoorrtt  is  zero,  then  it  is  set to the
              actual port that the remote program is listening on
              (the  remote  ppoorrttmmaapp service is consulted for this
              information). The parameter _s_o_c_k_p is a  socket;  if
              it  is  RRPPCC__AANNYYSSOOCCKK,  then this routine opens a new
              one and  sets  _s_o_c_k_p.   Since  TCP-based  RPC  uses
              buffered I/O , the user may specify the size of the
              send and receive buffers with the parameters _s_e_n_d_s_z
              and   _r_e_c_v_s_z;   values   of  zero  choose  suitable
              defaults.  This routine returns NULL if it fails.

       CCLLIIEENNTT **
       ccllnnttuuddpp__ccrreeaattee((aaddddrr,, pprrooggnnuumm,, vveerrssnnuumm,, wwaaiitt,, ssoocckkpp))
       ssttrruucctt ssoocckkaaddddrr__iinn **aaddddrr;;
       uu__lloonngg pprrooggnnuumm,, vveerrssnnuumm;;
       ssttrruucctt ttiimmeevvaall wwaaiitt;;
       iinntt **ssoocckkpp;;

              This routine creates an RPC client for  the  remote
              program  _p_r_o_g_n_u_m,  version _v_e_r_s_n_u_m; the client uses
              use UDP/IP as a transport. The  remote  program  is
              located    at    Internet    address    _a_d_d_r.    If
              aaddddrr-->>ssiinn__ppoorrtt is zero, then it is  set  to  actual



February                        16                              6





RPC(3N)                        1988                       RPC(3N)


              port  that  the remote program is listening on (the
              remote ppoorrttmmaapp service is consulted for this infor-
              mation).  The parameter _s_o_c_k_p is a socket; if it is
              RRPPCC__AANNYYSSOOCCKK, then this routine opens a new one  and
              sets  _s_o_c_k_p.   The  UDP  transport resends the call
              message in intervals of wwaaiitt time until a  response
              is received or until the call times out.  The total
              time for the call  to  time  out  is  specified  by
              ccllnntt__ccaallll(()).

              Warning: since UDP-based RPC messages can only hold
              up to 8 Kbytes of encoded data, this transport can-
              not  be  used  for procedures that take large argu-
              ments or return huge results.

       CCLLIIEENNTT **
       ccllnnttuuddpp__bbuuffccrreeaattee((aaddddrr,, pprrooggnnuumm,, vveerrssnnuumm,, wwaaiitt,, ssoocckkpp,, sseennddssiizzee,, rreeccoossiizzee))
       ssttrruucctt ssoocckkaaddddrr__iinn **aaddddrr;;
       uu__lloonngg pprrooggnnuumm,, vveerrssnnuumm;;
       ssttrruucctt ttiimmeevvaall wwaaiitt;;
       iinntt **ssoocckkpp;;
       uunnssiiggnneedd iinntt sseennddssiizzee;;
       uunnssiiggnneedd iinntt rreeccoossiizzee;;

              This routine creates an RPC client for  the  remote
              program  _p_r_o_g_n_u_m,  on  _v_e_r_s_n_u_m; the client uses use
              UDP/IP  as  a  transport.  The  remote  program  is
              located    at    Internet    address    _a_d_d_r.    If
              aaddddrr-->>ssiinn__ppoorrtt is zero, then it is  set  to  actual
              port  that  the remote program is listening on (the
              remote ppoorrttmmaapp service is consulted for this infor-
              mation).  The parameter _s_o_c_k_p is a socket; if it is
              RRPPCC__AANNYYSSOOCCKK, then this routine opens a new one  and
              sets  ssoocckkpp.   The  UDP  transport resends the call
              message in intervals of wwaaiitt time until a  response
              is received or until the call times out.  The total
              time for the call  to  time  out  is  specified  by
              ccllnntt__ccaallll(()).

              This  allows the user to specify the maximun packet
              size for sending and receiving UDP-based  RPC  mes-
              sages.

       vvooiidd
       ggeett__mmyyaaddddrreessss((aaddddrr))
       ssttrruucctt ssoocckkaaddddrr__iinn **aaddddrr;;

              Stuff  the machine's IP address into *_a_d_d_r, without
              consulting the  library  routines  that  deal  with
              //eettcc//hhoossttss.   The  port  number  is  always  set to
              hhttoonnss((PPMMAAPPPPOORRTT)).

       ssttrruucctt ppmmaapplliisstt **
       ppmmaapp__ggeettmmaappss((aaddddrr))



February                        16                              7





RPC(3N)                        1988                       RPC(3N)


       ssttrruucctt ssoocckkaaddddrr__iinn **aaddddrr;;

              A user interface  to  the  ppoorrttmmaapp  service,  which
              returns  a  list of the current RPC program-to-port
              mappings on the host located at IP  address  *_a_d_d_r.
              This   routine  can  return  NULL  .   The  command
              `rrppcciinnffoo --pp' uses this routine.

       uu__sshhoorrtt
       ppmmaapp__ggeettppoorrtt((aaddddrr,, pprrooggnnuumm,, vveerrssnnuumm,, pprroottooccooll))
       ssttrruucctt ssoocckkaaddddrr__iinn **aaddddrr;;
       uu__lloonngg pprrooggnnuumm,, vveerrssnnuumm,, pprroottooccooll;;

              A user interface  to  the  ppoorrttmmaapp  service,  which
              returns  the  port  number on which waits a service
              that supports program number _p_r_o_g_n_u_m, version  _v_e_r-
              _s_n_u_m,  and speaks the transport protocol associated
              with _p_r_o_t_o_c_o_l.   The  value  of  _p_r_o_t_o_c_o_l  is  most
              likely  IIPPPPRROOTTOO__UUDDPP or IIPPPPRROOTTOO__TTCCPP.  A return value
              of zero means that the mapping does  not  exist  or
              that  the RPC system failured to contact the remote
              ppoorrttmmaapp service.  In the latter  case,  the  global
              variable rrppcc__ccrreeaatteeeerrrr(()) contains the RPC status.

       eennuumm ccllnntt__ssttaatt
       ppmmaapp__rrmmttccaallll((aaddddrr,, pprrooggnnuumm,, vveerrssnnuumm,, pprrooccnnuumm,, iinnpprroocc,, iinn,, oouuttpprroocc,, oouutt,, ttoouutt,, ppoorrttpp))
       ssttrruucctt ssoocckkaaddddrr__iinn **aaddddrr;;
       uu__lloonngg pprrooggnnuumm,, vveerrssnnuumm,, pprrooccnnuumm;;
       cchhaarr **iinn,, **oouutt;;
       xxddrrpprroocc__tt iinnpprroocc,, oouuttpprroocc;;
       ssttrruucctt ttiimmeevvaall ttoouutt;;
       uu__lloonngg **ppoorrttpp;;

              A  user  interface  to  the  ppoorrttmmaapp service, which
              instructs ppoorrttmmaapp on the host at IP  address  *_a_d_d_r
              to  make  an RPC call on your behalf to a procedure
              on that host.  The parameter *_p_o_r_t_p will  be  modi-
              fied  to the program's port number if the procedure
              succeeds. The definitions of other  parameters  are
              discussed  in ccaallllrrppcc(()) and ccllnntt__ccaallll(()).  This pro-
              cedure should be used for a ping and nothing  else.
              See also ccllnntt__bbrrooaaddccaasstt(()).

       ppmmaapp__sseett((pprrooggnnuumm,, vveerrssnnuumm,, pprroottooccooll,, ppoorrtt))
       uu__lloonngg pprrooggnnuumm,, vveerrssnnuumm,, pprroottooccooll;;
       uu__sshhoorrtt ppoorrtt;;

              A  user  interface  to  the  ppoorrttmmaapp service, which
              establishes   a   mapping   between   the    triple
              [_p_r_o_g_n_u_m,_v_e_r_s_n_u_m,_p_r_o_t_o_c_o_l]    and   _p_o_r_t   on   the
              machine's ppoorrttmmaapp service. The value of _p_r_o_t_o_c_o_l is
              most  likely IIPPPPRROOTTOO__UUDDPP or IIPPPPRROOTTOO__TTCCPP.  This rou-
              tine returns one if it  succeeds,  zero  otherwise.
              Automatically done by ssvvcc__rreeggiisstteerr(()).



February                        16                              8





RPC(3N)                        1988                       RPC(3N)


       ppmmaapp__uunnsseett((pprrooggnnuumm,, vveerrssnnuumm))
       uu__lloonngg pprrooggnnuumm,, vveerrssnnuumm;;

              A  user  interface  to  the  ppoorrttmmaapp service, which
              destroys   all   mapping   between    the    triple
              [_p_r_o_g_n_u_m,_v_e_r_s_n_u_m,*]  and  ppoorrttss  on  the  machine's
              ppoorrttmmaapp service. This routine  returns  one  if  it
              succeeds, zero otherwise.

       rreeggiisstteerrrrppcc((pprrooggnnuumm,, vveerrssnnuumm,, pprrooccnnuumm,, pprrooccnnaammee,, iinnpprroocc,, oouuttpprroocc))
       uu__lloonngg pprrooggnnuumm,, vveerrssnnuumm,, pprrooccnnuumm;;
       cchhaarr **((**pprrooccnnaammee)) (()) ;;
       xxddrrpprroocc__tt iinnpprroocc,, oouuttpprroocc;;

              Register  procedure  _p_r_o_c_n_a_m_e  with the RPC service
              package.  If a request arrives for program _p_r_o_g_n_u_m,
              version _v_e_r_s_n_u_m, and procedure _p_r_o_c_n_u_m, _p_r_o_c_n_a_m_e is
              called with a pointer to its parameter(s); _p_r_o_g_n_a_m_e
              should  return  a  pointer to its static result(s);
              _i_n_p_r_o_c is used to decode the parameters while  _o_u_t-
              _p_r_o_c  is  used to encode the results.  This routine
              returns zero  if  the  registration  succeeded,  -1
              otherwise.

              Warning:  remote procedures registered in this form
              are  accessed  using  the  UDP/IP  transport;   see
              ssvvccuuddpp__ccrreeaattee(()) for restrictions.

       ssttrruucctt rrppcc__ccrreeaatteeeerrrr     rrppcc__ccrreeaatteeeerrrr;;

              A  global  variable  whose  value is set by any RPC
              client creation routine that does not succeed.  Use
              the routine ccllnntt__ppccrreeaatteeeerrrroorr(()) to print the reason
              why.

       ssvvcc__ddeessttrrooyy((xxpprrtt))
       SSVVCCXXPPRRTT **
       xxpprrtt;;

              A macro that destroys  the  RPC  service  transport
              handle, _x_p_r_t.  Destruction usually involves deallo-
              cation of private data structures,  including  _x_p_r_t
              itself.   Use  of  _x_p_r_t  is undefined after calling
              this routine.

       ffdd__sseett ssvvcc__ffddsseett;;

              A global variable reflecting the RPC service side's
              read  file descriptor bit mask; it is suitable as a
              parameter to the sseelleecctt system call. This  is  only
              of  interest if a service implementor does not call
              ssvvcc__rruunn(()), but rather  does  his  own  asynchronous
              event  processing.   This variable is read-only (do
              not pass its address to sseelleecctt!), yet it may change



February                        16                              9





RPC(3N)                        1988                       RPC(3N)


              after calls to ssvvcc__ggeettrreeqqsseett(()) or any creation rou-
              tines.

       iinntt ssvvcc__ffddss;;

              Similar to ssvvcc__ffeeddsseett(()), but limited to 32 descrip-
              tors. This interface is obsoleted by ssvvcc__ffddsseett(()).

       ssvvcc__ffrreeeeaarrggss((xxpprrtt,, iinnpprroocc,, iinn))
       SSVVCCXXPPRRTT **xxpprrtt;;
       xxddrrpprroocc__tt iinnpprroocc;;
       cchhaarr **iinn;;

              A  macro  that  frees  any  data  allocated  by the
              RPC/XDR system when it decoded the arguments  to  a
              service  procedure  using ssvvcc__ggeettaarrggss(()).  This rou-
              tine returns 1 if  the  results  were  successfully
              freed, and zero otherwise.

       ssvvcc__ggeettaarrggss((xxpprrtt,, iinnpprroocc,, iinn))
       SSVVCCXXPPRRTT **xxpprrtt;;
       xxddrrpprroocc__tt iinnpprroocc;;
       cchhaarr **iinn;;

              A  macro  that  decodes  the  arguments  of  an RPC
              request associated with the RPC  service  transport
              handle,  _x_p_r_t.   The  parameter  _i_n  is the address
              where the arguments will be placed; _i_n_p_r_o_c  is  the
              XDR  routine  used  to  decode the arguments.  This
              routine returns one if decoding succeeds, and  zero
              otherwise.

       ssttrruucctt ssoocckkaaddddrr__iinn **
       ssvvcc__ggeettccaalllleerr((xxpprrtt))
       SSVVCCXXPPRRTT **xxpprrtt;;

              The  approved way of getting the network address of
              the caller of a procedure associated with  the  RPC
              service transport handle, _x_p_r_t.

       ssvvcc__ggeettrreeqqsseett((rrddffddss))
       ffdd__sseett **rrddffddss;;

              This  routine  is  only  of  interest  if a service
              implementor does not call  ssvvcc__rruunn(()),  but  instead
              implements  custom  asynchronous  event processing.
              It is called when the sseelleecctt system call has deter-
              mined  that  an RPC request has arrived on some RPC
              ssoocckkeett((ss))  ;;  _r_d_f_d_s  is  the  resultant  read  file
              descriptor  bit mask.  The routine returns when all
              sockets associated with the  value  of  _r_d_f_d_s  have
              been serviced.

       ssvvcc__ggeettrreeqq((rrddffddss))



February                        16                             10





RPC(3N)                        1988                       RPC(3N)


       iinntt rrddffddss;;

              Similar  to  ssvvcc__ggeettrreeqqsseett(()),  but  limited  to  32
              descriptors.  This  interface   is   obsoleted   by
              ssvvcc__ggeettrreeqqsseett(()).

       ssvvcc__rreeggiisstteerr((xxpprrtt,, pprrooggnnuumm,, vveerrssnnuumm,, ddiissppaattcchh,, pprroottooccooll))
       SSVVCCXXPPRRTT **xxpprrtt;;
       uu__lloonngg pprrooggnnuumm,, vveerrssnnuumm;;
       vvooiidd ((**ddiissppaattcchh)) (());;
       uu__lloonngg pprroottooccooll;;

              Associates  _p_r_o_g_n_u_m  and  _v_e_r_s_n_u_m  with the service
              dispatch procedure, _d_i_s_p_a_t_c_h.  If _p_r_o_t_o_c_o_l is zero,
              the service is not registered with the ppoorrttmmaapp ser-
              vice.  If _p_r_o_t_o_c_o_l is non-zero, then a  mapping  of
              the     triple     [_p_r_o_g_n_u_m,_v_e_r_s_n_u_m,_p_r_o_t_o_c_o_l]    to
              xxpprrtt-->>xxpp__ppoorrtt is established with the local ppoorrttmmaapp
              service (generally _p_r_o_t_o_c_o_l is zero, IIPPPPRROOTTOO__UUDDPP or
              IIPPPPRROOTTOO__TTCCPP ).  The procedure _d_i_s_p_a_t_c_h has the fol-
              lowing form:
                 ddiissppaattcchh((rreeqquueesstt,, xxpprrtt))
                 ssttrruucctt ssvvcc__rreeqq **rreeqquueesstt;;
                 SSVVCCXXPPRRTT **xxpprrtt;;

              The  ssvvcc__rreeggiisstteerr(())  routine returns one if it suc-
              ceeds, and zero otherwise.

       ssvvcc__rruunn(())

              This  routine  never  returns.  It  waits  for  RPC
              requests  to arrive, and calls the appropriate ser-
              vice procedure using ssvvcc__ggeettrreeqq(()) when one arrives.
              This  procedure  is  usually waiting for a sseelleecctt(())
              system call to return.

       ssvvcc__sseennddrreeppllyy((xxpprrtt,, oouuttpprroocc,, oouutt))
       SSVVCCXXPPRRTT **xxpprrtt;;
       xxddrrpprroocc__tt oouuttpprroocc;;
       cchhaarr **oouutt;;

              Called by an RPC service's dispatch routine to send
              the results of a remote procedure call.  The param-
              eter _x_p_r_t is  the  request's  associated  transport
              handle; _o_u_t_p_r_o_c is the XDR routine which is used to
              encode the results; and _o_u_t is the address  of  the
              results.   This routine returns one if it succeeds,
              zero otherwise.

       vvooiidd
       ssvvcc__uunnrreeggiisstteerr((pprrooggnnuumm,, vveerrssnnuumm))
       uu__lloonngg pprrooggnnuumm,, vveerrssnnuumm;;

              Remove all mapping of the double  [_p_r_o_g_n_u_m,_v_e_r_s_n_u_m]



February                        16                             11





RPC(3N)                        1988                       RPC(3N)


              to   dispatch   routines,   and   of   the   triple
              [_p_r_o_g_n_u_m,_v_e_r_s_n_u_m,*] to port number.

       vvooiidd
       ssvvcceerrrr__aauutthh((xxpprrtt,, wwhhyy))
       SSVVCCXXPPRRTT **xxpprrtt;;
       eennuumm aauutthh__ssttaatt wwhhyy;;

              Called by a service dispatch routine  that  refuses
              to  perform  a  remote  procedure  call  due  to an
              authentication error.

       vvooiidd
       ssvvcceerrrr__ddeeccooddee((xxpprrtt))
       SSVVCCXXPPRRTT **xxpprrtt;;

              Called by a service dispatch  routine  that  cannot
              successfully   decode   its  parameters.  See  also
              ssvvcc__ggeettaarrggss(()).

       vvooiidd
       ssvvcceerrrr__nnoopprroocc((xxpprrtt))
       SSVVCCXXPPRRTT **xxpprrtt;;

              Called by a service dispatch routine that does  not
              implement  the  procedure  number  that  the caller
              requests.

       vvooiidd
       ssvvcceerrrr__nnoopprroogg((xxpprrtt))
       SSVVCCXXPPRRTT **xxpprrtt;;

              Called when the desired program is  not  registered
              with  the RPC package. Service implementors usually
              do not need this routine.

       vvooiidd
       ssvvcceerrrr__pprrooggvveerrss((xxpprrtt))
       SSVVCCXXPPRRTT **xxpprrtt;;

              Called when the desired version of a program is not
              registered  with the RPC package. Service implemen-
              tors usually do not need this routine.

       vvooiidd
       ssvvcceerrrr__ssyysstteemmeerrrr((xxpprrtt))
       SSVVCCXXPPRRTT **xxpprrtt;;

              Called  by  a  service  dispatch  routine  when  it
              detects  a system error not covered by any particu-
              lar protocol.  For example, if  a  service  can  no
              longer  allocate storage, it may call this routine.

       vvooiidd



February                        16                             12





RPC(3N)                        1988                       RPC(3N)


       ssvvcceerrrr__wweeaakkaauutthh((xxpprrtt))
       SSVVCCXXPPRRTT **xxpprrtt;;

              Called by a service dispatch routine  that  refuses
              to  perform a remote procedure call due to insuffi-
              cient authentication parameters.  The routine calls
              ssvvcceerrrr__aauutthh((xxpprrtt,, AAUUTTHH__TTOOOOWWEEAAKK)).

       SSVVCCXXPPRRTT **
       ssvvccrraaww__ccrreeaattee(())

              This  routine  creates a toy RPC service transport,
              to which it returns a pointer.   The  transport  is
              really a buffer within the process's address space,
              so the corresponding RPC client should live in  the
              same  address  space;  see  ccllnnttrraaww__ccrreeaattee(()).  This
              routine allows simulation of RPC and acquisition of
              RPC  overheads  (such as round trip times), without
              any kernel interference.  This routine returns NULL
              if it fails.

       SSVVCCXXPPRRTT **
       ssvvccttccpp__ccrreeaattee((ssoocckk,, sseenndd__bbuuff__ssiizzee,, rreeccvv__bbuuff__ssiizzee))
       iinntt ssoocckk;;
       uu__iinntt sseenndd__bbuuff__ssiizzee,, rreeccvv__bbuuff__ssiizzee;;

              This  routine  creates  a  TCP/IP-based RPC service
              transport, to which  it  returns  a  pointer.   The
              transport is associated with the socket _s_o_c_k, which
              may be RRPPCC__AANNYYSSOOCCKK, in which case a new  socket  is
              created.  If the socket is not bound to a local TCP
              port, then this routine binds it  to  an  arbitrary
              port.  Upon completion, xxpprrtt-->>xxpp__ssoocckk is the trans-
              port's socket descriptor, and xxpprrtt-->>xxpp__ppoorrtt is  the
              transport's port number.  This routine returns NULL
              if it fails. Since TCP-based RPC uses buffered  I/O
              ,  users may specify the size of buffers; values of
              zero choose suitable defaults.

       SSVVCCXXPPRRTT **
       ssvvccffdd__ccrreeaattee((ffdd,, sseennddssiizzee,, rreeccvvssiizzee))
       iinntt ffdd;;
       uu__iinntt sseennddssiizzee;;
       uu__iinntt rreeccvvssiizzee;;

              Create a service on top  of  any  open  descriptor.
              Typically,  this  descriptor  is a connected socket
              for a stream protocol such as  TCP.   _s_e_n_d_s_i_z_e  and
              _r_e_c_v_s_i_z_e  indicate  sizes  for the send and receive
              buffers.  If they are zero, a reasonable default is
              chosen.

       SSVVCCXXPPRRTT **
       ssvvccuuddpp__bbuuffccrreeaattee((ssoocckk,, sseennddssiizzee,, rreeccoossiizzee))



February                        16                             13





RPC(3N)                        1988                       RPC(3N)


       iinntt ssoocckk;;

              This  routine  creates  a  UDP/IP-based RPC service
              transport, to which  it  returns  a  pointer.   The
              transport is associated with the socket _s_o_c_k, which
              may be RRPPCC__AANNYYSSOOCCKK ,, in which case a new socket  is
              created.  If the socket is not bound to a local UDP
              port, then this routine binds it  to  an  arbitrary
              port.  Upon completion, xxpprrtt-->>xxpp__ssoocckk is the trans-
              port's socket descriptor, and xxpprrtt-->>xxpp__ppoorrtt is  the
              transport's port number.  This routine returns NULL
              if it fails.

              This allows the user to specify the maximun  packet
              size  for  sending and receiving UDP-based RPC mes-
              sages.

       xxddrr__aacccceepptteedd__rreeppllyy((xxddrrss,, aarr))
       XXDDRR **xxddrrss;;
       ssttrruucctt aacccceepptteedd__rreeppllyy **aarr;;

              Used for encoding RPC reply messages. This  routine
              is  useful for users who wish to generate RPC-style
              messages without using the RPC package.

       xxddrr__aauutthhuunniixx__ppaarrmmss((xxddrrss,, aauupppp))
       XXDDRR **xxddrrss;;
       ssttrruucctt aauutthhuunniixx__ppaarrmmss **aauupppp;;

              Used for describing UNIX credentials. This  routine
              is useful for users who wish to generate these cre-
              dentials without using the RPC authentication pack-
              age.

       vvooiidd
       xxddrr__ccaallllhhddrr((xxddrrss,, cchhddrr))
       XXDDRR **xxddrrss;;
       ssttrruucctt rrppcc__mmssgg **cchhddrr;;

              Used for describing RPC call header messages.  This
              routine is useful for users who  wish  to  generate
              RPC-style messages without using the RPC package.

       xxddrr__ccaallllmmssgg((xxddrrss,, ccmmssgg))
       XXDDRR **xxddrrss;;
       ssttrruucctt rrppcc__mmssgg **ccmmssgg;;

              Used  for  describing RPC call messages.  This rou-
              tine is useful for users who wish to generate  RPC-
              style messages without using the RPC package.

       xxddrr__ooppaaqquuee__aauutthh((xxddrrss,, aapp))
       XXDDRR **xxddrrss;;
       ssttrruucctt ooppaaqquuee__aauutthh **aapp;;



February                        16                             14





RPC(3N)                        1988                       RPC(3N)


              Used  for describing RPC authentication information
              messages.  This routine is  useful  for  users  who
              wish  to  generate RPC-style messages without using
              the RPC package.

       xxddrr__ppmmaapp((xxddrrss,, rreeggss))
       XXDDRR **xxddrrss;;
       ssttrruucctt ppmmaapp **rreeggss;;

              Used for describing parameters to  various  ppoorrttmmaapp
              procedures, externally.  This routine is useful for
              users who wish to generate these parameters without
              using the ppmmaapp interface.

       xxddrr__ppmmaapplliisstt((xxddrrss,, rrpp))
       XXDDRR **xxddrrss;;
       ssttrruucctt ppmmaapplliisstt ****rrpp;;

              Used for describing a list of port mappings, exter-
              nally.  This routine is useful for users  who  wish
              to generate these parameters without using the ppmmaapp
              interface.

       xxddrr__rreejjeecctteedd__rreeppllyy((xxddrrss,, rrrr))
       XXDDRR **xxddrrss;;
       ssttrruucctt rreejjeecctteedd__rreeppllyy **rrrr;;

              Used for describing RPC reply messages.  This  rou-
              tine  is useful for users who wish to generate RPC-
              style messages without using the RPC package.

       xxddrr__rreeppllyymmssgg((xxddrrss,, rrmmssgg))
       XXDDRR **xxddrrss;;
       ssttrruucctt rrppcc__mmssgg **rrmmssgg;;

              Used for describing RPC reply messages.  This  rou-
              tine  is  useful for users who wish to generate RPC
              style messages without using the RPC package.

       vvooiidd
       xxpprrtt__rreeggiisstteerr((xxpprrtt))
       SSVVCCXXPPRRTT **xxpprrtt;;

              After RPC service transport  handles  are  created,
              they  should  register themselves with the RPC ser-
              vice package.  This  routine  modifies  the  global
              variable  ssvvcc__ffddss(()).   Service implementors usually
              do not need this routine.

       vvooiidd
       xxpprrtt__uunnrreeggiisstteerr((xxpprrtt))
       SSVVCCXXPPRRTT **xxpprrtt;;

              Before  an  RPC   service   transport   handle   is



February                        16                             15





RPC(3N)                        1988                       RPC(3N)


              destroyed, it should unregister itself with the RPC
              service package.  This routine modifies the  global
              variable  ssvvcc__ffddss(()).   Service implementors usually
              do not need this routine.

SSEEEE AALLSSOO
       rrppcc__sseeccuurree(3N), xxddrr(3N)
       The following manuals:
              _R_e_m_o_t_e _P_r_o_c_e_d_u_r_e _C_a_l_l_s: _P_r_o_t_o_c_o_l _S_p_e_c_i_f_i_c_a_t_i_o_n
              _R_e_m_o_t_e _P_r_o_c_e_d_u_r_e _C_a_l_l _P_r_o_g_r_a_m_m_i_n_g _G_u_i_d_e
              _r_p_c_g_e_n _P_r_o_g_r_a_m_m_i_n_g _G_u_i_d_e
       _R_P_C:  _R_e_m_o_t_e  _P_r_o_c_e_d_u_r_e   _C_a_l_l   _P_r_o_t_o_c_o_l   _S_p_e_c_i_f_i_c_a_t_i_o_n,
       RFC1050, Sun Microsystems, Inc., USC-ISI.












































February                        16                             16


